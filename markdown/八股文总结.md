[TOC]



# 八股文总结

## 1. Mysql 

#### 1.1 常用存储引擎

InnoDB, MyISAM, MEMORY(HEAP, 这个是将数据存储在内存中，速度快不持久，适用于临时表，但是一般也可以用redis替代), 

ARCHIVE(效存储大批量归档数据，压缩率高，不支持索引（除主键外), 一般也用ES代替了)。其他没必要记，面试官自己也是翻八股文，他们也记不住。

#### 1.2 **常见索引数据结构:**

**B+树(必掌握)**, 其他没必要记。

#### 1.3 索引常见问题:

##### Q1 B+, B, 红黑树区别，为什么要用B+树

##### Q2 B+树的叶子节点是一行数据么？(冷知识点)

并不是，叶子节点一般是一页大小，一般默认16KB。

**为什么是16KB**:  

首先**操作系统磁盘IO都是采用页为单位进行**, 16KB算是较大的页，可以有效减少IO操作, 而且，16KB是大多数操作系统默认的页大小的倍数。

这个页大小也比较适中，不会因为页过小增加内存和磁盘随便的管理。

##### Q3 一般实际应用中B+树高度不超过多少比较合适

现在分布式计算中，一般主键采用bigint 数据结构去存储数据，bigint是8字节，一般B+树高度不要超过3层，还要考虑每页节点指针开销等，差不多3层结构能存储大约400万数据。尽量保证2层是比较合适的。在两层情况下，如果每行记录差不多1KB大小，其实一张表也就37M左右。如果按照3层高度情况下，差不多能占用4GB左右

##### Q4 什么是聚簇索引，二级索引(联合索引)

聚簇索引概念上就是索引页和表页存储在一块关联，一般都是主键索引，聚簇索引在Mysql表中一定存在，按照定义主键 >unique索引> 隐藏行id顺序去创建。二级索引其实就是非聚簇索引，二级索引的叶子节点存储的是二级索引相关字段和关联的主键，所以一般用二级索引检索会进行一次回表（根据查询到的主键再去聚簇索引查询具体的值）。除非查询的字段均在二级索引中。

##### Q5 Mysql 会针对Sql进行优化，有可能会自己优化到全表扫描

尤其是涉及到order by 的情况，有时候在内存中排序还真可能比回表N次快。

##### Q6 Mysql 在对字段执行 操作，类型转换，就用不了索引

大多数情况下是这样的，在以下情况下会导致索引无效。

1. **字段操作导致索引无法使用**

   当你对一个字段执行操作（如计算、函数调用等），查询优化器无法直接使用索引，因为操作后的值与索引中存储的值不匹配。例如:

   ```sql
   SELECT * FROM employees WHERE UPPER(last_name) = 'SMITH';
   ```

   在这种情况下，`UPPER(last_name)` 会对字段进行操作，使得原始的 `last_name` 索引无法直接用于查询。

2. **类型转换导致索引无法使用**

   如果查询中的字段类型与索引字段类型不匹配，并且需要进行类型转换，索引通常也无法有效使用。例如：

   ```sql
   SELECT * FROM orders WHERE order_id = 12345;
   ```

   因为 `order_id` 是字符串类型，MySQL 会将 `12345` 转换为字符串类型 `'12345'`。如果 `order_id` 上有索引，这种类型转换可能会导致索引无法使用，因为转换后的值与索引中的存储值不直接匹配。

**当然，在很多情况下，也是能够用索引的**

1. **隐式类型转换**

   某些隐式类型转换，特别是数值类型之间的转换，可能不会影响索引的使用。例如，整数和浮点数之间的比较，MySQL 通常会处理得很好。

   ```sql
   CREATE TABLE test_table (
       id INT,
       value INT,
       PRIMARY KEY (id)
   );
   
   SELECT * FROM test_table WHERE id = 123.0;
   ```

   在这种情况下，即使 `id` 是整数类型，而查询中使用了浮点数常量 `123.0`，MySQL 仍然能够使用主键索引来查找 `id` 为 `123` 的记录。

2. **字符串数值之间转换**

   在某些情况下，字符串和数值之间的转换可能仍然允许使用索引。例如，如果字符串能够精确地转换为数值，MySQL 可能会使用索引。

   ```sql
   CREATE TABLE orders (
       order_id VARCHAR(20),
       PRIMARY KEY (order_id)
   );
   
   SELECT * FROM orders WHERE order_id = '12345';
   ```

   尽管 `order_id` 是 `VARCHAR` 类型，但在这种情况下，MySQL 可以直接使用索引，因为字符串 `'12345'` 可以被精确匹配。

3. **索引最前缀匹配**

   对于前缀匹配查询，MySQL 可以使用索引。例如，如果在 `VARCHAR` 列上有索引，查询字符串的前缀可以使用索引。

   ```sql
   CREATE TABLE users (
       username VARCHAR(50),
       INDEX (username)
   );
   
   SELECT * FROM users WHERE username LIKE 'abc%';
   ```

4. **索引列的类型是字符串**

   当索引列是字符串类型时，MySQL 通常能够处理简单的字符串比较和转换。例如：

   ```sql
   CREATE TABLE products (
       sku VARCHAR(20),
       INDEX (sku)
   );
   
   SELECT * FROM products WHERE sku = 12345;
   ```

   即使 `sku` 是 `VARCHAR` 类型，查询中使用了整数常量 `12345`，MySQL 通常会将 `12345` 隐式转换为字符串 `'12345'`，从而使用索引。

**总结：**

Mysql 对这种情况不可能给你临时简历索引去查询，然后因为类型转换和字段操作，会导致原索引的顺序无效，所以也不会再去走索引查询，如果真想用索引，应当创建一个虚拟列去关联某一列数据再去创建索引。当然，Mysql也会尽力去转换查询条件和索引类型，使他们能够尽量去匹配。例如在一些数字直接的类型转换，数字和字符串如果能相互兼容转换的时候，还是会优化成利用索引。

****

#### 1.4: Mysql 事务和锁

**按锁粒度分:**

1. 行锁: 锁行数据，锁粒度最小，并发高。
2. 表锁: 锁整表，锁粒度最大，并发低。
3. 间隙锁： 锁一个区间。

**还可以分为:**

1. 共享锁: 读锁，一个事物给某行加了读锁，其他事务只可读不可写。
2. 排它锁: 写锁，一个事物给某行加了写锁，其他事物就不能读写。

**悲观锁，乐观锁:**

1. 乐观锁: 不会真的去锁某行，而是通过版本号实现。
2. 悲观锁: 行锁，表锁都是悲观锁。

## 2.JVM

 ### 2.1 ClassLoader 和双亲委派机制

JVM 主要分为4种ClassLoader: BootstrapClassLoader, ExtensionClassLoader(PlatformClassLoader Java9 以上), ApplicantionClassLoader, Custom ClassLoader.

从类加载机制上，采用双亲委派的模型，保证类加载的安全和一致性（主要是限制开发者随意改动java内部类包这种通用性的类）

1. JVM在加载类的时候，会首先将类加载工作委派给父类ClassLoader。
2. 父类会继续向上委派，直到BootstrapClassLoader。
3. 父类如果能找到并加载该类，就直接返回该类的`Class`对象了
4. 如果父 ClassLoader 无法找到该类，当前的 ClassLoader 才会尝试加载该类。

PlatformClassLoader 和 ExtensionClassLoader 区别

PlatformClassLoader 支持在java9以上定义的模块化java，模块化java在编译成jar时候会有一个module-info.class去告诉加载器需要加载的类和module需要依赖的环境，最后通过PlatformClassLoader替换成对应的java类。

### 2.2 native 关键字

其实就是JNI接口的定义，主要是用于一些底层操作系统调用（线程操作，文件IO操作等), 这些操作需要C语言去执行。

### JVM 模型

